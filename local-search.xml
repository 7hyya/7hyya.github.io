<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>new article</title>
    <link href="/2020/04/27/new-article/"/>
    <url>/2020/04/27/new-article/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试题--List集合如何去重</title>
    <link href="/2020/04/27/%E9%9D%A2%E8%AF%95%E9%A2%98--List%E9%9B%86%E5%90%88%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D/"/>
    <url>/2020/04/27/%E9%9D%A2%E8%AF%95%E9%A2%98--List%E9%9B%86%E5%90%88%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="List集合如何去重"><a href="#List集合如何去重" class="headerlink" title="List集合如何去重"></a>List集合如何去重</h1><p>在个人经历人生的第一次面试的时候，面试官上来的第一个问题就是问个Java基础，说一下List如何去重吧！</p><p>在正常情况下，我是能在自己独立思考的基础上想出一个办法的，但是在面试官的面前就突然大脑空白了。在出公司大楼之后，复盘整个面试过程，立马就想到了List如何去重，方法如下：</p><h3 id="1-用Set集合"><a href="#1-用Set集合" class="headerlink" title="1. 用Set集合"></a>1. 用Set集合</h3><pre><code class="java">public static List&lt;String&gt; del_duplication(List&lt;String&gt; list){    // 用TreeSet    List&lt;String&gt; listNew = new ArrayList&lt;String&gt;(new TreeSet&lt;String&gt;(list));    return listNew;}public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;1&quot;);        list.add(&quot;2&quot;);        list.add(&quot;3&quot;);        list.add(&quot;4&quot;);        list.add(&quot;5&quot;);        list.add(&quot;6&quot;);        list.add(&quot;2&quot;);        list.add(&quot;1&quot;);        System.out.println(&quot;去重前：&quot;+list);        list = del_duplication(list);        System.out.println(&quot;去重后：&quot;+list);    }</code></pre><p>控制台输出结果：</p><p>去重前：[1, 2, 3, 4, 5, 6, 2, 1]<br>去重后：[1, 2, 3, 4, 5, 6]</p><h3 id="2-新建一个List"><a href="#2-新建一个List" class="headerlink" title="2. 新建一个List"></a>2. 新建一个List</h3><pre><code class="java">    /**     * 遍历后判断赋给另一个list集合，保持原来顺序     *      * @param list     * @return     */    public static List&lt;String&gt; del_duplication2(List&lt;String&gt; list) {        List&lt;String&gt; listNew = new ArrayList&lt;String&gt;();        for (String str : list) {            if (!listNew.contains(str)) {                listNew.add(str);            }        }        return listNew;    }    public static void main(String[] args) {            List&lt;String&gt; list = new ArrayList&lt;String&gt;();            list.add(&quot;1&quot;);            list.add(&quot;2&quot;);            list.add(&quot;3&quot;);            list.add(&quot;4&quot;);            list.add(&quot;5&quot;);            list.add(&quot;6&quot;);            list.add(&quot;2&quot;);            list.add(&quot;1&quot;);            System.out.println(&quot;去重前：&quot;+list);            list = del_duplication(list);            System.out.println(&quot;去重后：&quot;+list);        }</code></pre><p>控制台输出结果：</p><p>去重前：[1, 2, 3, 4, 5, 6, 2, 1]<br>去重后：[1, 2, 3, 4, 5, 6]</p><h3 id="3-用JDK8的特性"><a href="#3-用JDK8的特性" class="headerlink" title="3. 用JDK8的特性"></a>3. 用JDK8的特性</h3><pre><code class="java">public static List&lt;String&gt; del_duplication(List&lt;String&gt; list) {        List&lt;String&gt; myList = list.stream().distinct().collect(Collectors.toList());        return myList;    }public static void main(String[] args) {            List&lt;String&gt; list = new ArrayList&lt;String&gt;();            list.add(&quot;1&quot;);            list.add(&quot;2&quot;);            list.add(&quot;3&quot;);            list.add(&quot;4&quot;);            list.add(&quot;5&quot;);            list.add(&quot;6&quot;);            list.add(&quot;2&quot;);            list.add(&quot;1&quot;);            System.out.println(&quot;去重前：&quot;+list);            list = del_duplication(list);            System.out.println(&quot;去重后：&quot;+list);        }</code></pre><p>控制台输出结果：</p><p>去重前：[1, 2, 3, 4, 5, 6, 2, 1]<br>去重后：[1, 2, 3, 4, 5, 6]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>String的==和equals()</title>
    <link href="/2020/04/27/String%E7%9A%84==%E5%92%8Cequals()/"/>
    <url>/2020/04/27/String%E7%9A%84==%E5%92%8Cequals()/</url>
    
    <content type="html"><![CDATA[<h1 id="String的-和equals"><a href="#String的-和equals" class="headerlink" title="String的==和equals()"></a>String的==和equals()</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String对象初始化"><a href="#String对象初始化" class="headerlink" title="String对象初始化"></a>String对象初始化</h3><ol><li><p>Method 1：</p><pre><code class="Java">String 字符串名 = &quot;字符串内容&quot;;</code></pre></li></ol><ol start="2"><li><p>Method 2:</p><pre><code class="Java">String 字符串名 = new String(&quot;字符串内容&quot;);</code></pre><p>上面两种格式生成的字符串效果是相同的，但是存储机制是存在很大区别的！</p></li></ol><p>Java为String类提供了一种称为缓存池机制的功能。使用Method 1的方式，直接赋值生成字符串，Java编译器总是先到缓冲池中去寻找是否存在相同内容的字符串。如果存在就可以直接使用，如果不存在则在缓冲池中创建一个新的字符串。使用Method 2的方式，用new关键字调用构造方法的方式，则每次调用都会生成一个新的String对象。</p><h3 id="String关于“-”和equals-的比较"><a href="#String关于“-”和equals-的比较" class="headerlink" title="String关于“==”和equals()的比较"></a>String关于“==”和equals()的比较</h3><ul><li><p>“==”是关系运算符，可以用于判断基本数据类型的变量值是否相等，或者判断引用类型变量的引用地址是否相同。</p></li><li><p>equals()方法，用于判断引用对象的引用地址所指向的存储内容是否相等。</p><p>纸上得来终觉浅，绝知此事要躬行，下面代码来证：</p><pre><code class="java">public class StringDemo {    public static void main(String[] args) {        String str1 = &quot;Java String test&quot;;        String str2 = &quot;Java String test&quot;;        String str3 = new String(&quot;Java String test&quot;);        String str4 = str3;        System.out.println(&quot;str1=&quot;+str1+&quot;、str2=&quot;+str2+&quot;\n&quot;+&quot;str3=&quot;+str3+&quot;、str4=&quot;+str4);        if (str1 == str2) {            System.out.println(&quot;str1 == str2: true&quot;);        }else {            System.out.println(&quot;str1 == str2: false&quot;);        }        if (str3 == str4) {            System.out.println(&quot;str3 == str4: true&quot;);        }else {            System.out.println(&quot;str3 == str4: false&quot;);        }        if (str1 == str3) {            System.out.println(&quot;str1 == str3: true&quot;);        }else {            System.out.println(&quot;str1 == str3: false&quot;);        }    }}</code></pre><p>运行之后输出结果如下：</p><pre><code>str1=Java String test、str2=Java String teststr3=Java String test、str4=Java String teststr1 == str2: truestr3 == str4: truestr1 == str3: false</code></pre><p>结合下图对象在内存中的地址，来进行深入理解一下：</p></li></ul><p><img src="D:%5C7hyyaBlog%5CHexo%5Cpublic%5Cimg%5CblogImages%5Cimage-20200427192325826.png" srcset="/img/loading.gif" alt="image-20200427192325826"></p><p>从上图中可知，String类型的内容是保存在堆内存中的，栈内存仅保存指向堆内存的地址，上面说到过String使用直接赋值生成对象，会用到缓冲池机制。在执行String str1 = “Java String test”时，在缓冲池中并没有“Java String test”字符串，所以生成一个“Java String test”字符串。执行到String str2 = “Java String test”时，缓冲池中已存在“Java String test”字符串，所以不需要生成一个新的“Java String test”字符串，而是直接使用该字符串。使用new关键字调用构造方法生成字符串时，不会用到缓冲池机制。每次调用一次就会生成一个新的字符串对象。</p><p>由于缓冲池机制，str1和str2使用相同的字符串对象，所以它们的内存地址是相等的，所以使用“==”关系运算符比较str1和str2结果值为true。同理，因为str1和str3指向不同的内存地址，所以str1==str3的结果值是false。从上图中可见，str3和str4指向同一内存地址，所以str3==str4的结果值为true。</p><p>上面通过代码来验证出了“==”是比较的对象的内存地址，下面看看equals()，上代码：</p><pre><code class="java">public class StringDemo {    public static void main(String[] args) {        String str1 = &quot;Java String test&quot;;        String str2 = &quot;Java String test&quot;;        String str3 = new String(&quot;Java String test&quot;);        String str4 = str3;        System.out.println(&quot;str1=&quot;+str1+&quot;、str2=&quot;+str2+&quot;\n&quot;+&quot;str3=&quot;+str3+&quot;、str4=&quot;+str4);        if (str1.equals(str2)) {            System.out.println(&quot;str1.equals(str2): true&quot;);        }else {            System.out.println(&quot;str1.equals(str2): false&quot;);        }        if (str3.equals(str4)) {            System.out.println(&quot;str3.equals(str4): true&quot;);        }else {            System.out.println(&quot;str3.equals(str4): false&quot;);        }        if (str1.equals(str3)) {            System.out.println(&quot;str1.equals(str3): true&quot;);        }else {            System.out.println(&quot;str1.equals(str3): false&quot;);        }    }}</code></pre><p>运行结果如下：</p><pre><code>str1=Java String test、str2=Java String teststr3=Java String test、str4=Java String teststr1.equals(str2): truestr3.equals(str4): truestr1.equals(str3): true</code></pre><p>由于equals()方法是Object类中定义的一个方法，所有的类都继承自Object类，因此该方法可以在其他引用类型中使用。在这里String已经重写了Object类的equals()方法。从运行结果并结合上图可以看出equals()方法是比较的引用对象的引用地址所指向的存储内容是否相等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>String初始化有两种方式，一般情况下是使用 <strong>String 字符串名 = “字符串内容”</strong> 的格式，因为此格式使用缓冲池机制执行效率高，节约内存。一个字符串就是一个String类的匿名对象，匿名对象是可以直接开辟堆内存并使用的对象。<strong>String 字符串 = new String(“字符串内容”)</strong>格式分别需要开辟一个栈内存和一个堆内存。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL常见的7种通用的Join查询</title>
    <link href="/2020/04/21/MySQL%E5%B8%B8%E8%A7%81%E7%9A%847%E7%A7%8D%E9%80%9A%E7%94%A8%E7%9A%84Join%E6%9F%A5%E8%AF%A2/"/>
    <url>/2020/04/21/MySQL%E5%B8%B8%E8%A7%81%E7%9A%847%E7%A7%8D%E9%80%9A%E7%94%A8%E7%9A%84Join%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL常见的7种通用的Join查询"><a href="#MySQL常见的7种通用的Join查询" class="headerlink" title="MySQL常见的7种通用的Join查询"></a>MySQL常见的7种通用的Join查询</h1><p>举例中的表记录如下：</p><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421175001635.png" srcset="/img/loading.gif" alt="Student表"></p><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421175111146.png" srcset="/img/loading.gif" alt="Course表"></p><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421175148223.png" srcset="/img/loading.gif" alt="选课表"></p><p><strong>SQL JOIN: SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</strong></p><ol><li>*<em>INNER JOIN (等值连接) *</em>只返回两个表中联结字段相等的行,如下图所示：</li></ol><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421174446625.png" srcset="/img/loading.gif" alt="image-20200421174446625"></p><p>SQL语句：</p><pre><code class="sql">SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.key = B.Key</code></pre><p>例如:</p><pre><code class="sql">SELECT * FROM student stu INNER JOIN sc s ON stu.Sno = s.Sno;</code></pre><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421175637331.png" srcset="/img/loading.gif" alt="image-20200421175637331"></p><ol start="2"><li><p><strong>LEFT JOIN(左连接)</strong>返回包括左表中的所有记录和右表中联结字段相等的记录 ，右表中没有匹配的填充NULL。</p><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421175935738.png" srcset="/img/loading.gif" alt="image-20200421175935738"></p></li></ol><p>SQL语句：</p><pre><code class="sql">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.key = B.Key</code></pre><p>例如：</p><pre><code class="sql">SELECT * FROM student stu LEFT JOIN sc s ON stu.Sno = s.Sno;</code></pre><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421180142185.png" srcset="/img/loading.gif" alt="image-20200421180142185"></p><ol start="3"><li><strong>RIGHT JOIN(右连接)</strong>返回包括右表中的所有记录和左表中联结字段相等的记录 ，左表中没有匹配的填充NULL。</li></ol><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421180500645.png" srcset="/img/loading.gif" alt="image-20200421180500645"></p><p>SQL语句：</p><pre><code class="sql">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key</code></pre><p>例如：</p><pre><code class="sql">SELECT * FROM student stu RIGHT JOIN sc s ON stu.Sno = s.Sno;</code></pre><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421180552332.png" srcset="/img/loading.gif" alt="image-20200421180552332"></p><p>4.</p><pre><code class="sql">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.key = B.Key WHERE B,key IS NULL</code></pre><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421181254415.png" srcset="/img/loading.gif" alt="image-20200421181254415"></p><p>5.</p><pre><code class="sql">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key WHERE B,key IS NULL</code></pre><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421181330315.png" srcset="/img/loading.gif" alt="image-20200421181330315"></p><p>6.</p><pre><code class="sql">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.key = B.Key UNION SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key</code></pre><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421181839975.png" srcset="/img/loading.gif" alt="image-20200421181839975"></p><p>7.</p><pre><code class="sql">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.key = B.Key WHERE B.key IS NULL UNION SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.key = B.Key WHERE A.key IS NULL;</code></pre><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421181956238.png" srcset="/img/loading.gif" alt="image-20200421181956238"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SimpleDateFormat日期格式化</title>
    <link href="/2020/04/04/SimpleDateFormat%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <url>/2020/04/04/SimpleDateFormat%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="SimpleDateFormat日期格式化"><a href="#SimpleDateFormat日期格式化" class="headerlink" title="SimpleDateFormat日期格式化"></a>SimpleDateFormat日期格式化</h3><p>​       通常在使用SimpleDateFormat对日期进行格式化的时候，使用的格式化模板一般为”yyyy-MM-dd HH:mm:ss”，最近这次按照老套路对日期进行格式化的时候，输入是将”yyyy-MM-dd HH:mm:ss”输入成”yyyy-MM-dd hh:mm:ss”了，在用echart生成图表时就出现了一些问题，刚开始以为数据库与Java的日期格式不匹配，最后才发现了是H的大小写的问题，于是就去全面的学习了一下日期格式中个字母代表的意义：</p><p>yyyy：年<br>MM：月<br>dd：日<br>hh：1~12小时制(1-12)<br>HH：24小时制(0-23)<br>mm：分<br>ss：秒<br>S：毫秒<br>E：星期几<br>D：一年中的第几天<br>F：一月中的第几个星期(会把这个月总共过的天数除以7)<br>w：一年中的第几个星期<br>W：一月中的第几星期(会根据实际情况来算)<br>a：上下午标识<br>k：与HH相同，24小时制(1-24)<br>K：与hh相同，12小时制</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/18/hello-world/"/>
    <url>/2020/03/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
